import "EMBED/u32_to_bits" as u32_to_bits
import "EMBED/u32_from_bits" as u32_from_bits
import "utils/casts/u32_4_to_bool_128.zok" as u32_4_to_bool_128
import "utils/pack/bool/pack128.zok" as pack_128_bool_to_field
import "utils/pack/bool/unpack128.zok" as unpack_field_to_128_bool
import "utils/pack/u32/unpack128.zok" as unpack_field_to_4_u32
import "utils/casts/u32_to_field" as to_field
import "hashes/sha256/1024bit.zok" as sha256for1024
import "hashes/sha256/256bitPadded.zok" as sha256only
import "./getHexLength.zok" as getHexLength

def toBigEndian<N>(bool[N] value) -> (bool[N]):
    assert(N % 8u32 == 0)
    bool[N] result = [false; N]

    for u32 i in 0..N / 8 do
        for u32 j in 0..8 do
            result[8 * i + j] = value[N - 8 * (i + 1) + j]
        endfor
    endfor

    return result

def packMaxVariance(u32 length) -> field:
    field result = 0
    for u32 i in 1..33 do
        result = if length == i then pack_128_bool_to_field([...[false; 128 - 4 * i], ...[true; 4 * i]]) else result fi
    endfor
    return result

def packTarget(bool[32] bits) -> (field):

    field packed = pack_128_bool_to_field([...[false; 120], ...bits[0..8]])

    field result = pack_128_bool_to_field([false; 128])

    for u32 i in 0..9 do
        result =\
            if packed == 32 - to_field(i) - 1 then\
                pack_128_bool_to_field([...[false; 8 * (i + 1)], ...bits[8..32], ...[false; 96 - 8 * i]])\
            else\
                result\
            fi
    endfor

    return result

def get_bit_length_bits(bool[24] bits) -> (u32):
    u32 result = 0
    for u32 i in 0..24 do
        result = if (result == 0) && (bits[i] == true) then 24-i else result fi
    endfor
return result

def get_hex_length_bits(bool[24] bits) -> u32:
    u32 bit_length = get_bit_length_bits(bits)
    u32 result = 0
    for u32 i in 0..6 do
        result = if bit_length > 4 * i then i else result fi
    endfor
    return result

// call with last field of block array
def validate_target(field epoch_head, u32 epoch_tail, u32 next_epoch_head) -> (bool, field):
    bool[128] epoch_head_unpacked = unpack_field_to_128_bool(epoch_head)
// 
    bool[32] epoch_tail_unpacked = u32_to_bits(epoch_tail)
    bool[32] next_epoch_head_unpacked = u32_to_bits(next_epoch_head)

    field time_head = pack_128_bool_to_field([...[false; 96], ...toBigEndian(epoch_head_unpacked[32..64])])
    field time_tail = pack_128_bool_to_field([...[false; 96], ...toBigEndian(epoch_tail_unpacked)])

    field current_target = packTarget(toBigEndian(epoch_head_unpacked[64..96]))
    field time_delta = time_tail - time_head
    field target_time_delta = 1209600 // 2016 * 600 (time interval of 10 minutes)

    field target = current_target * time_delta // target_time_delta

    field encoded_target = packTarget(toBigEndian(next_epoch_head_unpacked))
    field encoded_target_extended = encoded_target * target_time_delta

    // The encoding of targets uses a floor function, the comparison of a calculated target may therefore fail
    // Therefore, a maximum variance is calculated that is one hex digit in the encoding
    field maxVariance = packMaxVariance(getHexLength(target) - get_hex_length_bits(toBigEndian(next_epoch_head_unpacked[0..24])))
    
    // int('ffff' + 10 * '00', 16) * 2016 * 600 = 95832923060582736897701037735936000
    target = if target > 95832923060582736897701037735936000 then 95832923060582736897701037735936000 else target fi
    field delta = target - encoded_target_extended
    delta = if target >= encoded_target_extended then delta else maxVariance + 1 fi
    bool valid = if delta <= maxVariance then true else false fi
    return valid, current_target

def validate_block_header(u32 reference_target, u32[8] prev_block_hash, u32[20] preimage) -> (u32[8]):
	// preImage: [0] -> Block version, [1:8] -> prev_block_hash, [9:16] -> merkle root, [17:19] => time, target, nonce 
    assert(preimage[1..9] == prev_block_hash[0..8])
    
    // converting to big endian is not necessary here, as reference target is encoded little endian
    assert(preimage[18] == reference_target)
    u32[8] intermediary = sha256for1024(preimage[0..8], preimage[8..16], [...preimage[16..20], 0x80000000, ...[0x00000000; 3]], [...[0x00000000; 7], 0x00000280])
    u32[8] r = sha256only(intermediary)

    field target = packTarget(toBigEndian(u32_to_bits(preimage[18])))

    assert(target > pack_128_bool_to_field(toBigEndian(u32_4_to_bool_128(r[4..8]))))
	  return r

def main(field epoch_head, u32[8] prev_block_hash, private u32[2][20] intermediate_blocks, u32[20] final_block) -> (bool, field, u32[8]):

    u32 reference_target = unpack_field_to_4_u32(epoch_head)[2]

    u32[8] block_hash = prev_block_hash
    u32[3][8] blocks = [[0x00000000; 8]; 3]
    for u32 i in 0..2 do
      block_hash = validate_block_header(reference_target, block_hash, intermediate_blocks[i])
      blocks[i] = block_hash
    endfor

	block_hash = validate_block_header(final_block[18], block_hash, final_block)
	blocks[2] = block_hash
	bool targetValid, field target = validate_target(epoch_head, intermediate_blocks[0][17], final_block[18])

	return targetValid, target, blocks[2]


	// validate_block_header is run 3x: 1024bit -> 4 rounds, 256bit 2 rounds => 18 rounds total